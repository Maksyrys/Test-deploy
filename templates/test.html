package main

import "BookStore/internal/app"

func main() {
app.Run()
}
package handlers

import (
"BookStore/internal/app/utils"
"BookStore/internal/models"
"github.com/gorilla/mux"
"net/http"
"strconv"
)

func (h *Handler) IndexHandler(w http.ResponseWriter, r *http.Request) {
randomBooks, categories, err := h.bookService.GetIndexData(12)
if err != nil {
appErr := utils.NewAppError("Ошибка получения данных для главной страницы", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

user := utils.GetCurrentUser(r)
data := struct {
RandomBooks []models.Book
Categories  []models.Category
CurrentUser *models.User
}{
RandomBooks: randomBooks,
Categories:  categories,
CurrentUser: user,
}

utils.Render(w, "../../templates/index.html", data)
}

func (h *Handler) BookHandler(w http.ResponseWriter, r *http.Request) {
vars := mux.Vars(r)
idStr := vars["id"]
if idStr == "" {
appErr := utils.NewAppError("Отсутствует параметр id", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}

id, err := strconv.Atoi(idStr)
if err != nil {
appErr := utils.NewAppError("Неверный параметр id", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

user := utils.GetCurrentUser(r)
bookDetails, err := h.bookService.GetBookDetails(id, user)
if err != nil {
appErr := utils.NewAppError("Ошибка получения данных о книге", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

data := struct {
BooksByAuthor    map[string][]models.Book
AuthorBooks      []models.Book
Book             models.Book
CurrentUser      *models.User
InCart           bool
IsFavorite       bool
BookReviews      []models.Review
UserReviewExists bool
}{
BooksByAuthor:    bookDetails.BooksByAuthor,
AuthorBooks:      bookDetails.AuthorBooks,
Book:             bookDetails.Book,
CurrentUser:      user,
InCart:           bookDetails.InCart,
IsFavorite:       bookDetails.IsFavorite,
BookReviews:      bookDetails.BookReviews,
UserReviewExists: bookDetails.UserReviewExists,
}

utils.Render(w, "../../templates/book.html", data)
}

func (h *Handler) SearchHandler(w http.ResponseWriter, r *http.Request) {
query := r.URL.Query().Get("q")
user := utils.GetCurrentUser(r)

if query == "" {
data := struct {
CurrentUser *models.User
Query       string
Books       []models.Book
}{
CurrentUser: user,
Query:       "",
Books:       nil,
}
utils.Render(w, "../../templates/search.html", data)
return
}

books, err := h.bookService.SearchBooks(query)
if err != nil {
appErr := utils.NewAppError("Ошибка поиска", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

data := struct {
CurrentUser *models.User
Query       string
Books       []models.Book
}{
CurrentUser: user,
Query:       query,
Books:       books,
}

utils.Render(w, "../../templates/search.html", data)
}
package handlers

import (
"BookStore/internal/app/services"
"BookStore/internal/app/utils"
"BookStore/internal/models"
"fmt"
"net/http"
"strconv"
)

func (h *Handler) CartHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}

details, err := h.cartService.GetCartDetails(user.UserId)
if err != nil {
appErr := utils.NewAppError("Ошибка при получении корзины", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

data := struct {
CurrentUser   *models.User
Items         []services.CartItemDetail
GrandTotal    float64
TotalQuantity int
}{
CurrentUser:   user,
Items:         details.Items,
GrandTotal:    details.GrandTotal,
TotalQuantity: details.TotalQuantity,
}

utils.Render(w, "../../templates/cart.html", data)
}

func (h *Handler) AddToCartHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

bookIDStr := r.PostFormValue("book_id")
quantityStr := r.PostFormValue("quantity")
if bookIDStr == "" {
appErr := utils.NewAppError("Не указан идентификатор книги", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}
bookID, err := strconv.Atoi(bookIDStr)
if err != nil {
appErr := utils.NewAppError("Неверный идентификатор книги", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}
quantity := 1
if quantityStr != "" {
quantity, err = strconv.Atoi(quantityStr)
if err != nil {
appErr := utils.NewAppError("Неверное количество", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}
}

if err = h.cartService.AddItem(user.UserId, bookID, quantity); err != nil {
appErr := utils.NewAppError("Ошибка при добавлении в корзину", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(`{"success": true}`))
}

func (h *Handler) RemoveFromCartHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

bookIDStr := r.PostFormValue("book_id")
if bookIDStr == "" {
appErr := utils.NewAppError("Не указан идентификатор книги", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}
bookID, err := strconv.Atoi(bookIDStr)
if err != nil {
appErr := utils.NewAppError("Неверный идентификатор книги", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

if err = h.cartService.RemoveOneItem(user.UserId, bookID); err != nil {
appErr := utils.NewAppError("Ошибка при удалении из корзины", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(`{"success": true}`))
}

func (h *Handler) CartCountHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}

totalCount, err := h.cartService.GetCartCount(user.UserId)
if err != nil {
appErr := utils.NewAppError("Ошибка при получении количества товаров в корзине", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(fmt.Sprintf(`{"count": %d}`, totalCount)))
}

func (h *Handler) RemoveAllFromCartHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

bookIDStr := r.PostFormValue("book_id")
if bookIDStr == "" {
appErr := utils.NewAppError("Не указан идентификатор книги", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}
bookID, err := strconv.Atoi(bookIDStr)
if err != nil {
appErr := utils.NewAppError("Неверный идентификатор книги", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

if err = h.cartService.RemoveAllItems(user.UserId, bookID); err != nil {
appErr := utils.NewAppError("Ошибка при удалении из корзины", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(`{"success": true}`))
}
package handlers

import (
"BookStore/internal/app/utils"
"BookStore/internal/models"
"net/http"
)

// CatalogHandler получает данные каталога через сервис и рендерит шаблон.
func (h *Handler) CatalogHandler(w http.ResponseWriter, r *http.Request) {
catIDStr := r.URL.Query().Get("cat_id")
catalogData, err := h.catalogService.GetCatalogData(catIDStr)
if err != nil {
appErr := utils.NewAppError("Ошибка при получении категорий", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

user := utils.GetCurrentUser(r)
data := struct {
CurrentUser          *models.User
Categories           []models.Category
SelectedCategoryID   int
SelectedCategoryName string
Books                []models.Book
}{
CurrentUser:          user,
Categories:           catalogData.Categories,
SelectedCategoryID:   catalogData.SelectedCategoryID,
SelectedCategoryName: catalogData.SelectedCategoryName,
Books:                catalogData.Books,
}

utils.Render(w, "../../templates/catalog.html", data)
}
package handlers

import (
"BookStore/internal/app/utils"
"BookStore/internal/models"
"net/http"
"strconv"
)

func (h *Handler) FavoritesHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}

favorites, err := h.favoriteService.GetFavorites(user.UserId)
if err != nil {
appErr := utils.NewAppError("Ошибка получения избранного", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
data := struct {
CurrentUser *models.User
Favorites   []models.Book
}{
CurrentUser: user,
Favorites:   favorites,
}
utils.Render(w, "../../templates/favorites.html", data)
}

func (h *Handler) AddFavoriteHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}
bookIDStr := r.PostFormValue("book_id")
if bookIDStr == "" {
appErr := utils.NewAppError("Не указан идентификатор книги", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}
bookID, err := strconv.Atoi(bookIDStr)
if err != nil {
appErr := utils.NewAppError("Неверный идентификатор книги", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}
if err := h.favoriteService.AddFavorite(user.UserId, bookID); err != nil {
appErr := utils.NewAppError("Ошибка при добавлении в избранное", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(`{"success": true}`))
}

func (h *Handler) RemoveFavoriteHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}
bookIDStr := r.PostFormValue("book_id")
if bookIDStr == "" {
appErr := utils.NewAppError("Не указан идентификатор книги", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}
bookID, err := strconv.Atoi(bookIDStr)
if err != nil {
appErr := utils.NewAppError("Неверный идентификатор книги", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}
if err := h.favoriteService.RemoveFavorite(user.UserId, bookID); err != nil {
appErr := utils.NewAppError("Ошибка при удалении из избранного", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(`{"success": true}`))
}
package handlers

import (
"BookStore/internal/app/services"
"BookStore/internal/repository"
)

type Handler struct {
rep             *repository.Repository
userService     services.UserService
bookService     services.BookService
cartService     services.CartService
catalogService  services.CatalogService
favoriteService services.FavoriteService
reviewService   services.ReviewService
}

func NewHandler(rep *repository.Repository,
userService services.UserService,
bookService services.BookService,
cartService services.CartService,
catalogService services.CatalogService,
favoriteService services.FavoriteService,
reviewService services.ReviewService) *Handler {
return &Handler{rep: rep,
userService:     userService,
bookService:     bookService,
cartService:     cartService,
catalogService:  catalogService,
favoriteService: favoriteService,
reviewService:   reviewService}
}
package handlers

import (
"BookStore/internal/app/utils"
"BookStore/internal/models"
"encoding/json"
"fmt"
"github.com/gorilla/mux"
"net/http"
"strconv"
)

func (h *Handler) AddReviewHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}
bookID, err := strconv.Atoi(mux.Vars(r)["id"])
if err != nil {
appErr := utils.NewAppError("Некорректный id книги", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}
rating, err := strconv.Atoi(r.FormValue("rating"))
if err != nil {
appErr := utils.NewAppError("Некорректный рейтинг", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

review := models.Review{
UserID: user.UserId,
BookID: bookID,
Rating: rating,
}

if err := h.reviewService.CreateReview(review); err != nil {
appErr := utils.NewAppError("Ошибка при создании отзыва", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
http.Redirect(w, r, fmt.Sprintf("/book/%d", bookID), http.StatusSeeOther)
}

func (h *Handler) CreateReviewHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}

bookID, err := strconv.Atoi(r.FormValue("book_id"))
if err != nil {
appErr := utils.NewAppError("Некорректный book_id", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

rating, err := strconv.Atoi(r.FormValue("rating"))
if err != nil || rating < 1 || rating > 5 {
appErr := utils.NewAppError("Некорректный рейтинг", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

comment := r.FormValue("comment")
review := models.Review{
UserID:  user.UserId,
BookID:  bookID,
Rating:  rating,
Comment: comment,
}

if err := h.reviewService.CreateReview(review); err != nil {
appErr := utils.NewAppError("Ошибка сохранения отзыва", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

w.Header().Set("Content-Type", "application/json")
_ = json.NewEncoder(w).Encode(map[string]bool{"success": true})
}
package handlers

import (
"BookStore/internal/app/utils"
"BookStore/internal/models"
"go.uber.org/zap"
"net/http"
"strconv"
)

func (h *Handler) ProfileHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}

//// Предположим, что у вас реализованы методы для получения количества заказов и избранного:
//ordersCount, err := h.orderService.GetOrdersCount(user.UserId)
//if err != nil {
//	appErr := utils.NewAppError("Ошибка получения кол-ва заказов", http.StatusBadRequest, nil)
//	utils.RespondWithError(w, appErr)
//	return
//}

favoritesCount, err := h.favoriteService.GetFavoritesCount(user.UserId)
if err != nil {
appErr := utils.NewAppError("Ошибка получения кол-ва избранных", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}

cartCount, err := h.cartService.GetCartCount(user.UserId)
if err != nil {
appErr := utils.NewAppError("Ошибка получения кол-ва книг в корзине", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}

reviews, err := h.userService.GetUserReviews(user.UserId)
if err != nil {
appErr := utils.NewAppError("Ошибка получения отзывов", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

data := struct {
CurrentUser    *models.User
FavoritesCount int
CartCount      int
UserReviews    []models.Review
}{
CurrentUser:    user,
UserReviews:    reviews,
FavoritesCount: favoritesCount,
CartCount:      cartCount,
}

utils.Render(w, "../../templates/profile.html", data)
}

func (h *Handler) EditProfileHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil {
appErr := utils.NewAppError("Пользователь не авторизован", http.StatusUnauthorized, nil)
utils.RespondWithError(w, appErr)
return
}

if r.Method == http.MethodPost {
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

user.Username = r.FormValue("username")
user.Firstname = r.FormValue("firstname")
user.Lastname = r.FormValue("lastname")
user.Phone = r.FormValue("phone")

if err := h.userService.UpdateProfile(user); err != nil {
appErr := utils.NewAppError("Ошибка обновления профиля", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}
http.Redirect(w, r, "/profile", http.StatusSeeOther)
return
}

data := struct {
CurrentUser *models.User
}{
CurrentUser: user,
}
utils.Render(w, "../../templates/edit_profile.html", data)
}

func (h *Handler) RegisterHandler(w http.ResponseWriter, r *http.Request) {
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

email := r.PostFormValue("reg-email")
password := r.PostFormValue("reg-password")
username := r.PostFormValue("reg-username")

if email == "" || username == "" || password == "" {
appErr := utils.NewAppError("Необходимо заполнить все поля", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}

newUserID, err := h.userService.RegisterUser(email, password, username)
if err != nil {
appErr := utils.NewAppError("Ошибка при создании пользователя", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

utils.SetUserSessionCookie(w, newUserID)
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(`{"success": true}`))
}

func (h *Handler) LoginHandler(w http.ResponseWriter, r *http.Request) {
if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

email := r.FormValue("login-email")
password := r.FormValue("login-password")
// Здесь можно добавить структурированное логирование попытки входа
utils.Logger.Info("Попытка входа", zap.String("email", email))
user, err := h.userService.LoginUser(email, password)
if err != nil {
appErr := utils.NewAppError("Пользователь не найден или неверный пароль", http.StatusUnauthorized, err)
utils.RespondWithError(w, appErr)
return
}

utils.SetUserSessionCookie(w, user.UserId)
w.Header().Set("Content-Type", "application/json")
_, _ = w.Write([]byte(`{"success": true}`))
}

func (h *Handler) LogoutHandler(w http.ResponseWriter, r *http.Request) {
cookie := http.Cookie{
Name:     "session_user_id",
Value:    "",
Path:     "/",
MaxAge:   -1,
HttpOnly: true,
}
http.SetCookie(w, &cookie)
http.Redirect(w, r, "/", http.StatusSeeOther)
}

func (h *Handler) AdminDashboardHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil || user.Role != "admin" {
appErr := utils.NewAppError("Доступ запрещён", http.StatusForbidden, nil)
utils.RespondWithError(w, appErr)
return
}

books := h.bookService.GetAllBooks()
reviews, err := h.reviewService.GetAllReviews()
if err != nil {
appErr := utils.NewAppError("Ошибка получения отзывов", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

categories, err := h.rep.Book.GetAllCategories()
if err != nil {
appErr := utils.NewAppError("Ошибка получения категорий", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

data := struct {
CurrentUser *models.User
Books       []models.Book
Reviews     []models.Review
Categories  []models.Category
}{
CurrentUser: user,
Books:       books,
Reviews:     reviews,
Categories:  categories,
}
utils.Render(w, "../../templates/admin.html", data)
}

func (h *Handler) AdminAddBookHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil || user.Role != "admin" {
appErr := utils.NewAppError("Доступ запрещён", http.StatusForbidden, nil)
utils.RespondWithError(w, appErr)
return
}

if err := r.ParseForm(); err != nil {
appErr := utils.NewAppError("Ошибка парсинга формы", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

title := r.FormValue("title")
author := r.FormValue("author")
category := r.FormValue("category")
price, _ := strconv.ParseFloat(r.FormValue("price"), 64)
description := r.FormValue("description")
detailedDescription := r.FormValue("detailed_description")

book := models.Book{
Title:               title,
Author:              author,
Category:            category,
Price:               price,
Description:         description,
DetailedDescription: detailedDescription,
}

if err := h.bookService.AddBook(book); err != nil {
appErr := utils.NewAppError("Ошибка при добавлении книги", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

http.Redirect(w, r, "/admin", http.StatusSeeOther)
}

func (h *Handler) AdminDeleteBookHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil || user.Role != "admin" {
appErr := utils.NewAppError("Доступ запрещён", http.StatusForbidden, nil)
utils.RespondWithError(w, appErr)
return
}

idStr := r.FormValue("id")
if idStr == "" {
appErr := utils.NewAppError("Не указан id книги", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}
id, err := strconv.Atoi(idStr)
if err != nil {
appErr := utils.NewAppError("Некорректный id", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

if err := h.bookService.DeleteBook(id); err != nil {
appErr := utils.NewAppError("Ошибка удаления книги", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

http.Redirect(w, r, "/admin", http.StatusSeeOther)
}

func (h *Handler) AdminDeleteReviewHandler(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil || user.Role != "admin" {
appErr := utils.NewAppError("Доступ запрещён", http.StatusForbidden, nil)
utils.RespondWithError(w, appErr)
return
}

reviewIDStr := r.FormValue("id")
if reviewIDStr == "" {
appErr := utils.NewAppError("Не указан id отзыва", http.StatusBadRequest, nil)
utils.RespondWithError(w, appErr)
return
}
reviewID, err := strconv.Atoi(reviewIDStr)
if err != nil {
appErr := utils.NewAppError("Некорректный id отзыва", http.StatusBadRequest, err)
utils.RespondWithError(w, appErr)
return
}

if err := h.reviewService.DeleteReview(reviewID); err != nil {
appErr := utils.NewAppError("Ошибка удаления отзыва", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
return
}

http.Redirect(w, r, "/admin", http.StatusSeeOther)
}
package middlewares

import (
"BookStore/internal/app/utils"
"BookStore/internal/repository"
"context"
"errors"
"fmt"
"go.uber.org/zap"
"net/http"
"strconv"
)

type Middleware struct {
rep *repository.Repository
}

func NewMiddleware(rep *repository.Repository) *Middleware {
return &Middleware{rep: rep}
}

func LoggingMiddleware(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
utils.Logger.Info("Запрос",
zap.String("method", r.Method),
zap.String("uri", r.RequestURI),
)
next.ServeHTTP(w, r)
})
}

func RecoveryMiddleware(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
defer func() {
if rec := recover(); rec != nil {
// Приводим panic к типу error
var err error
if recErr, ok := rec.(error); ok {
err = recErr
} else {
err = fmt.Errorf("%v", rec)
}
utils.Logger.Error("Паника в обработчике", zap.Error(err))
appErr := utils.NewAppError("Внутренняя ошибка сервера", http.StatusInternalServerError, err)
utils.RespondWithError(w, appErr)
}
}()
next.ServeHTTP(w, r)
})
}

func CorsMiddleware(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
w.Header().Set("Access-Control-Allow-Origin", "*")
w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
// Если это preflight-запрос, завершаем обработку.
if r.Method == "OPTIONS" {
return
}
next.ServeHTTP(w, r)
})
}

func (m *Middleware) UserSessionMiddleware(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
cookie, err := r.Cookie("session_user_id")
if err == nil && cookie.Value != "" {
userID, err := strconv.Atoi(cookie.Value)
if err == nil {
user, err := m.rep.User.GetUserByID(userID)
if err == nil {
utils.Logger.Info("Пользователь авторизован",
zap.String("username", user.Username),
zap.Int("userID", user.UserId),
zap.String("role", user.Role),
)
ctx := context.WithValue(r.Context(), utils.UserContextKey, &user)
r = r.WithContext(ctx)
} else {
// Логирование ошибки получения пользователя, но не прерываем выполнение
utils.Logger.Warn("Не удалось получить пользователя по ID", zap.Int("userID", userID), zap.Error(err))
}
} else {
utils.Logger.Warn("Неверное значение cookie session_user_id", zap.String("cookie", cookie.Value))
}
}
next.ServeHTTP(w, r)
})
}

func AdminMiddleware(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
user := utils.GetCurrentUser(r)
if user == nil || user.Role != "admin" {
appErr := utils.NewAppError("Доступ запрещён", http.StatusForbidden, errors.New("user is not admin"))
utils.RespondWithError(w, appErr)
return
}
next.ServeHTTP(w, r)
})
}
package services

import (
"BookStore/internal/models"
"BookStore/internal/repository"
)

// BookService описывает бизнес-логику, связанную с книгами.
type BookService interface {
// GetIndexData возвращает случайный набор книг и список категорий для главной страницы.
GetIndexData(limit int) ([]models.Book, []models.Category, error)
// GetBookDetails формирует детальную информацию о книге, включая данные по автору, корзине, избранному и отзывам.
GetBookDetails(bookID int, user *models.User) (*BookDetails, error)
// SearchBooks выполняет поиск книг по запросу.
SearchBooks(query string) ([]models.Book, error)
AddBook(book models.Book) error
DeleteBook(id int) error
GetAllBooks() []models.Book
}

// bookService — конкретная реализация BookService.
type bookService struct {
rep *repository.Repository
}

// NewBookService создаёт новый экземпляр BookService.
func NewBookService(rep *repository.Repository) BookService {
return &bookService{rep: rep}
}

// BookDetails содержит данные для отображения страницы книги.
type BookDetails struct {
BooksByAuthor    map[string][]models.Book
AuthorBooks      []models.Book
Book             models.Book
InCart           bool
IsFavorite       bool
BookReviews      []models.Review
UserReviewExists bool
}

// GetIndexData получает случайные книги и список категорий.
func (s *bookService) GetIndexData(limit int) ([]models.Book, []models.Category, error) {
randomBooks, err := s.rep.Book.GetRandomBooks(limit)
if err != nil {
return nil, nil, err
}
categories, err := s.rep.Book.GetAllCategories()
if err != nil {
return nil, nil, err
}
return randomBooks, categories, nil
}

// GetBookDetails собирает всю необходимую информацию для страницы книги.
func (s *bookService) GetBookDetails(bookID int, user *models.User) (*BookDetails, error) {
// Получаем книги, сгруппированные по автору.
booksByAuthor, err := s.rep.Book.GetBooksByGroupedByAuthorRandom()
if err != nil {
return nil, err
}

// Получаем конкретную книгу.
book, err := s.rep.Book.GetBookByID(bookID)
if err != nil {
return nil, err
}

inCart := false
isFavorite := false
userReviewExists := false

if user != nil {
// Проверяем, находится ли книга в корзине.
cartItems, err := s.rep.Cart.GetCartItems(user.UserId)
if err == nil {
for _, item := range cartItems {
if item.BookID == book.ID {
inCart = true
break
}
}
}
// Проверяем, является ли книга избранной.
isFavorite, err = s.rep.Favorite.IsFavorite(user.UserId, book.ID)
if err != nil {
// Можно добавить логирование ошибки, но не прерывать выполнение.
}
// Проверяем, оставлял ли пользователь отзыв на эту книгу.
userReviewExists, _ = s.rep.Review.UserHasReviewed(user.UserId, book.ID)
}

// Получаем книги того же автора.
authorBooks := booksByAuthor[book.Author]
if len(authorBooks) > 6 {
authorBooks = authorBooks[:6]
}

// Получаем отзывы к книге.
reviews, err := s.rep.Review.GetReviewsByBookID(book.ID)
if err != nil {
return nil, err
}

details := &BookDetails{
BooksByAuthor:    booksByAuthor,
AuthorBooks:      authorBooks,
Book:             book,
InCart:           inCart,
IsFavorite:       isFavorite,
BookReviews:      reviews,
UserReviewExists: userReviewExists,
}

return details, nil
}

// SearchBooks выполняет поиск книг по заданному запросу.
func (s *bookService) SearchBooks(query string) ([]models.Book, error) {
return s.rep.Book.SearchBooks(query)
}

// AddBook вызывает метод репозитория для добавления книги.
func (s *bookService) AddBook(book models.Book) error {
return s.rep.Book.InsertBook(book)
}

// DeleteBook вызывает метод репозитория для удаления книги.
func (s *bookService) DeleteBook(id int) error {
return s.rep.Book.DeleteBook(id)
}

func (s *bookService) GetAllBooks() []models.Book {
return s.rep.Book.GetBooks()
}
package services

import (
"BookStore/internal/models"
"BookStore/internal/repository"
)

// CartItemDetail – структура для представления элемента корзины в шаблоне.
type CartItemDetail struct {
Book     models.Book // Данные книги.
Quantity int         // Количество экземпляров.
Total    float64     // Стоимость (Quantity * Price).
}

// CartDetails – структура, содержащая детальную информацию о корзине.
type CartDetails struct {
Items         []CartItemDetail // Список элементов корзины.
GrandTotal    float64          // Общая стоимость корзины.
TotalQuantity int              // Общее количество книг.
}

// CartService описывает бизнес-логику, связанную с корзиной.
type CartService interface {
// GetCartDetails возвращает детальную информацию по корзине пользователя.
GetCartDetails(userID int) (*CartDetails, error)
// AddItem добавляет товар в корзину.
AddItem(userID, bookID, quantity int) error
// RemoveOneItem уменьшает количество товара на единицу или удаляет его, если их осталось 1.
RemoveOneItem(userID, bookID int) error
// RemoveAllItems удаляет все экземпляры товара из корзины.
RemoveAllItems(userID, bookID int) error
// GetCartCount возвращает общее количество товаров в корзине.
GetCartCount(userID int) (int, error)
}

// cartService — конкретная реализация CartService.
type cartService struct {
rep *repository.Repository
}

// NewCartService создаёт новый экземпляр CartService.
func NewCartService(rep *repository.Repository) CartService {
return &cartService{rep: rep}
}

// GetCartDetails получает список элементов корзины и вычисляет общую стоимость и количество.
func (s *cartService) GetCartDetails(userID int) (*CartDetails, error) {
cartItems, err := s.rep.Cart.GetCartItems(userID)
if err != nil {
return nil, err
}

var details CartDetails

for _, item := range cartItems {
// Получаем данные книги по идентификатору.
book, err := s.rep.Book.GetBookByID(item.BookID)
if err != nil {
// Если не удалось получить книгу, пропускаем элемент.
continue
}
total := float64(item.Quantity) * book.Price
details.GrandTotal += total
details.TotalQuantity += item.Quantity

details.Items = append(details.Items, CartItemDetail{
Book:     book,
Quantity: item.Quantity,
Total:    total,
})
}

return &details, nil
}

// AddItem добавляет товар в корзину через репозиторий.
func (s *cartService) AddItem(userID, bookID, quantity int) error {
return s.rep.Cart.AddItem(userID, bookID, quantity)
}

// RemoveOneItem уменьшает количество товара на 1 или удаляет его, если их 1.
func (s *cartService) RemoveOneItem(userID, bookID int) error {
return s.rep.Cart.RemoveOneItem(userID, bookID)
}

// RemoveAllItems удаляет все экземпляры товара из корзины.
func (s *cartService) RemoveAllItems(userID, bookID int) error {
return s.rep.Cart.RemoveItems(userID, bookID)
}

// GetCartCount подсчитывает общее количество товаров в корзине.
func (s *cartService) GetCartCount(userID int) (int, error) {
cartItems, err := s.rep.Cart.GetCartItems(userID)
if err != nil {
return 0, err
}
totalCount := 0
for _, item := range cartItems {
totalCount += item.Quantity
}
return totalCount, nil
}
package services

import (
"BookStore/internal/models"
"BookStore/internal/repository"
"strconv"
)

// CatalogData содержит данные каталога для отображения в шаблоне.
type CatalogData struct {
Categories           []models.Category // Все категории
SelectedCategoryID   int               // Идентификатор выбранной категории
SelectedCategoryName string            // Название выбранной категории
Books                []models.Book     // Книги выбранной категории
}

// CatalogService описывает бизнес-логику получения данных каталога.
type CatalogService interface {
// GetCatalogData получает данные каталога на основе переданного catID (в виде строки).
GetCatalogData(catIDStr string) (*CatalogData, error)
}

type catalogService struct {
rep *repository.Repository
}

// NewCatalogService создаёт новый экземпляр catalogService.
func NewCatalogService(rep *repository.Repository) CatalogService {
return &catalogService{rep: rep}
}

// GetCatalogData получает все категории, а если задан идентификатор категории,
// то получает книги этой категории и название выбранной категории.
func (s *catalogService) GetCatalogData(catIDStr string) (*CatalogData, error) {
// Получаем все категории
categories, err := s.rep.Book.GetAllCategories()
if err != nil {
return nil, err
}

data := &CatalogData{
Categories: categories,
}

// Если нет ни одной категории, просто возвращаем data
if len(categories) == 0 {
return data, nil
}

var catID int
// Если catIDStr задан, пытаемся конвертировать его в число
if catIDStr != "" {
if parsedID, err := strconv.Atoi(catIDStr); err == nil && parsedID > 0 {
catID = parsedID
}
}

// Если catID всё ещё 0 (не задан или некорректен),
// берём первую категорию из списка
if catID == 0 {
catID = categories[0].ID
}

// Устанавливаем выбранную категорию
data.SelectedCategoryID = catID

// Получаем книги для выбранной категории
books, err := s.rep.Book.GetBooksByCategoryID(catID)
if err != nil {
return nil, err
}
data.Books = books

// Находим название выбранной категории
for _, c := range categories {
if c.ID == catID {
data.SelectedCategoryName = c.Name
break
}
}

return data, nil
}
package services

import (
"BookStore/internal/models"
"BookStore/internal/repository"
)

// FavoriteService описывает бизнес-логику работы с избранным.
type FavoriteService interface {
// GetFavorites возвращает список избранных книг пользователя.
GetFavorites(userID int) ([]models.Book, error)
// AddFavorite добавляет книгу в избранное пользователя.
AddFavorite(userID, bookID int) error
// RemoveFavorite удаляет книгу из избранного пользователя.
RemoveFavorite(userID, bookID int) error
GetFavoritesCount(userID int) (int, error)
}

type favoriteService struct {
rep *repository.Repository
}

// NewFavoriteService создаёт новый экземпляр FavoriteService.
func NewFavoriteService(rep *repository.Repository) FavoriteService {
return &favoriteService{rep: rep}
}

func (s *favoriteService) GetFavorites(userID int) ([]models.Book, error) {
return s.rep.Favorite.GetFavorites(userID)
}

func (s *favoriteService) AddFavorite(userID, bookID int) error {
return s.rep.Favorite.AddFavorite(userID, bookID)
}

func (s *favoriteService) RemoveFavorite(userID, bookID int) error {
return s.rep.Favorite.RemoveFavorite(userID, bookID)
}

func (s *favoriteService) GetFavoritesCount(userID int) (int, error) {
favotiteItems, err := s.rep.Favorite.CountFavorites(userID)
if err != nil {
return 0, err
}
return favotiteItems, err
}
package services

import (
"BookStore/internal/models"
"BookStore/internal/repository"
"fmt"
"time"
)

// ReviewService описывает бизнес-логику работы с отзывами.
type ReviewService interface {
// CreateReview сохраняет отзыв, проводя базовую валидацию и установку времени создания, если необходимо.
CreateReview(review models.Review) error
DeleteReview(reviewID int) error
GetAllReviews() ([]models.Review, error)
}

// reviewService — конкретная реализация ReviewService.
type reviewService struct {
rep *repository.Repository
}

// NewReviewService создаёт новый экземпляр ReviewService.
func NewReviewService(rep *repository.Repository) ReviewService {
return &reviewService{rep: rep}
}

// CreateReview выполняет базовую валидацию и сохраняет отзыв через репозиторий.
func (s *reviewService) CreateReview(review models.Review) error {
// Пример базовой валидации рейтинга.
if review.Rating < 1 || review.Rating > 5 {
return fmt.Errorf("некорректный рейтинг: %d", review.Rating)
}
// Если время создания не задано, устанавливаем текущее время.
if review.Created.IsZero() {
review.Created = time.Now()
}
return s.rep.Review.CreateReview(review)
}

func (s *reviewService) DeleteReview(reviewID int) error {
return s.rep.Review.DeleteReview(reviewID)
}

func (s *reviewService) GetAllReviews() ([]models.Review, error) {
return s.rep.Review.GetAllReviews()
}
package services

import (
"BookStore/internal/app/utils"
"BookStore/internal/models"
"BookStore/internal/repository"
"errors"
"log"
)

type UserService interface {
GetUserReviews(userID int) ([]models.Review, error)
UpdateProfile(user *models.User) error
RegisterUser(email, password, username string) (int, error)
LoginUser(email, password string) (models.User, error)
}

type userService struct {
rep *repository.Repository
}

func NewUserService(rep *repository.Repository) UserService {
return &userService{rep: rep}
}

func (s *userService) GetUserReviews(userID int) ([]models.Review, error) {
return s.rep.Review.GetUserReviews(userID)
}

func (s *userService) UpdateProfile(user *models.User) error {
return s.rep.User.UpdateUserProfile(*user)
}

func (s *userService) RegisterUser(email, password, username string) (int, error) {
hashedPassword, err := utils.HashPassword(password)
if err != nil {
return 0, err
}

user := models.User{
Email:    email,
Password: hashedPassword,
Username: username,
}

return s.rep.User.CreateUser(user)
}

func (s *userService) LoginUser(email, password string) (models.User, error) {
user, err := s.rep.User.GetUserByEmail(email)
if err != nil {
log.Printf("Ошибка получения пользователя по email %q: %v", email, err)
return user, err
}

// Логируем хеш пароля, полученный из БД
log.Printf("Пользователь найден: %s, хеш пароля: %s", user.Username, user.Password)

// Проверяем введённый пароль и логируем результат сравнения
if !utils.CheckPasswordHash(password, user.Password) {
log.Printf("Сравнение хеша не прошло. Введённый пароль: %q, ожидаемый хеш: %s", password, user.Password)
return user, errors.New("Неверный пароль")
}

return user, nil
}
package utils

import (
"encoding/json"
"go.uber.org/zap"
"net/http"
)

// AppError — структура для передачи ошибок в ответах.
type AppError struct {
Message string `json:"message"`
Code    int    `json:"code"`
// Поле Err не экспортируется в JSON-ответе
Err error `json:"-"`
}

// Error реализует интерфейс error.
func (e *AppError) Error() string {
return e.Message
}

// NewAppError создаёт новый экземпляр AppError.
func NewAppError(message string, code int, err error) *AppError {
return &AppError{
Message: message,
Code:    code,
Err:     err,
}
}

// RespondWithError отправляет JSON-ответ с ошибкой и логирует её.
func RespondWithError(w http.ResponseWriter, appErr *AppError) {
Logger.Error("Ошибка",
// Логируем как можно больше контекста (можно добавить дополнительные поля)
// например, ключ "internal_error", чтобы не отправлять его клиенту.
zap.Error(appErr.Err),
zap.Int("status", appErr.Code),
zap.String("message", appErr.Message),
)
w.Header().Set("Content-Type", "application/json")
w.WriteHeader(appErr.Code)
_ = json.NewEncoder(w).Encode(appErr)
}
package utils

import (
"go.uber.org/zap"
)

// Logger — глобальный экземпляр логгера.
var Logger *zap.Logger

// InitLogger инициализирует zap Logger.
func InitLogger() error {
var err error
Logger, err = zap.NewProduction() // Можно использовать NewDevelopment() для режима разработки.
if err != nil {
return err
}
zap.ReplaceGlobals(Logger)
return nil
}
package utils

import (
"BookStore/internal/models"
"bytes"
"golang.org/x/crypto/bcrypt"
"html/template"
"io"
"mime/multipart"
"net/http"
"os"
"path/filepath"
"strconv"
"time"
)

type contextKey string

const UserContextKey = contextKey("currentUser")

func GetCurrentUser(r *http.Request) *models.User {
val := r.Context().Value(UserContextKey)
if val == nil {
return nil
}
user, ok := val.(*models.User)
if !ok {
return nil
}
return user
}

func HashPassword(password string) (string, error) {
bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
return string(bytes), err
}

func CheckPasswordHash(password, hash string) bool {
err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
return err == nil
}

func SetUserSessionCookie(w http.ResponseWriter, userID int) {
cookie := http.Cookie{
Name:     "session_user_id",
Value:    strconv.Itoa(userID),
Path:     "/",
HttpOnly: true,
}
http.SetCookie(w, &cookie)
}

func Render(w http.ResponseWriter, templateFile string, data interface{}) {
tmpl := template.Must(template.ParseFiles(
"../../templates/layout.html",
"../../templates/header.html",
"../../templates/modal.html",
"../../templates/footer.html",
templateFile,
))

var buf bytes.Buffer
err := tmpl.ExecuteTemplate(&buf, "layout", data)
if err != nil {
http.Error(w, err.Error(), http.StatusInternalServerError)
return
}

w.Header().Set("Content-Type", "text/html; charset=utf-8")
_, _ = buf.WriteTo(w)
}

func SaveUploadedFile(file multipart.File, header *multipart.FileHeader) (string, error) {
fileExt := filepath.Ext(header.Filename)
fileName := strconv.FormatInt(time.Now().UnixNano(), 10) + fileExt

filePath := filepath.Join("static", "uploads", fileName)
dest, err := os.Create(filePath)
if err != nil {
return "", err
}
defer dest.Close()

_, err = io.Copy(dest, file)
if err != nil {
return "", err
}

// Исправляем слеши:
webFilePath := "/" + filepath.ToSlash(filePath)

return webFilePath, nil
}
package app

import (
"BookStore/internal/app/handlers"
"BookStore/internal/app/middlewares"
"BookStore/internal/app/services"
"BookStore/internal/app/utils"
"BookStore/internal/config"
"BookStore/internal/repository"
"BookStore/internal/repository/postgresql"
"database/sql"
"fmt"
"log"
)

type App struct {
rep     *repository.Repository
handler *handlers.Handler
middle  *middlewares.Middleware
cfg     *config.Config
}

func NewApp(rep *repository.Repository) *App {
userService := services.NewUserService(rep)
bookService := services.NewBookService(rep)
cartService := services.NewCartService(rep)
catalogService := services.NewCatalogService(rep)
favoriteService := services.NewFavoriteService(rep)
reviewService := services.NewReviewService(rep)
return &App{rep: rep,
handler: handlers.NewHandler(rep, userService, bookService, cartService, catalogService, favoriteService, reviewService),
middle:  middlewares.NewMiddleware(rep),
cfg:     nil}
}

func InitApp(db *sql.DB, cfg *config.Config) (*App, error) {
rep := repository.NewRepository(db)
app := NewApp(rep)

InitRouter(app, cfg)

return app, nil
}

func Run() {

// Инициализация логгера
if err := utils.InitLogger(); err != nil {
// Если логгер не инициализировался, то можно использовать стандартный log
panic("Не удалось инициализировать логгер: " + err.Error())
}
defer utils.Logger.Sync()

cfg := config.NewConfig()

db, err := InitDB(cfg)
if err != nil {
log.Fatal(err)
}
defer postgresql.CloseBD(db)

app, err := InitApp(db, cfg)
if err != nil {
log.Fatal(err)
}
fmt.Println(app)
}

func InitDB(cfg *config.Config) (*sql.DB, error) {
db, err := postgresql.NewBD(postgresql.Config{
Host:     cfg.BD.Host,
Port:     cfg.BD.Port,
Username: cfg.BD.Username,
Password: cfg.BD.Password,
BDName:   cfg.BD.BDName,
SSLMode:  cfg.BD.SSLMode,
})
if err != nil {
return nil, err
}
return db, nil
}
package app

import (
"BookStore/internal/app/middlewares"
"BookStore/internal/config"
"BookStore/internal/repository"
"github.com/gorilla/mux"
"log"
"net/http"
)

type Router struct {
router *mux.Router
}

func NewRouter(rep *repository.Repository) *Router {
return &Router{router: mux.NewRouter()}
}

func InitRouter(app *App, cfg *config.Config) {
router := mux.NewRouter()

router.Use(middlewares.LoggingMiddleware)
router.Use(middlewares.RecoveryMiddleware)
router.Use(middlewares.CorsMiddleware)
router.Use(app.middle.UserSessionMiddleware)

fs := http.FileServer(http.Dir(cfg.Dir))
router.PathPrefix("/static/").Handler(http.StripPrefix("/static/", fs))

router.HandleFunc("/", app.handler.IndexHandler).Methods("GET")
router.HandleFunc("/book/{id}", app.handler.BookHandler).Methods("GET")

router.HandleFunc("/register", app.handler.RegisterHandler).Methods("POST")
router.HandleFunc("/login", app.handler.LoginHandler).Methods("POST")

router.HandleFunc("/profile", app.handler.ProfileHandler).Methods("GET")
router.HandleFunc("/search", app.handler.SearchHandler).Methods("GET")

router.HandleFunc("/cart", app.handler.CartHandler).Methods("GET")
router.HandleFunc("/cart/add", app.handler.AddToCartHandler).Methods("POST")
router.HandleFunc("/cart/remove", app.handler.RemoveFromCartHandler).Methods("POST")
router.HandleFunc("/cart/checkout", app.handler.AddToCartHandler).Methods("POST")

router.HandleFunc("/logout", app.handler.LogoutHandler).Methods("GET")
router.HandleFunc("/cart/count", app.handler.CartCountHandler).Methods("GET")
router.HandleFunc("/cart/remove/all", app.handler.RemoveAllFromCartHandler).Methods("POST")

router.HandleFunc("/favorites", app.handler.FavoritesHandler).Methods("GET")
router.HandleFunc("/favorites/add", app.handler.AddFavoriteHandler).Methods("POST")
router.HandleFunc("/favorites/remove", app.handler.RemoveFavoriteHandler).Methods("POST")

router.HandleFunc("/catalog", app.handler.CatalogHandler).Methods("GET")
router.HandleFunc("/profile/edit", app.handler.EditProfileHandler).Methods("GET", "POST")
router.HandleFunc("/book/{id}/reviews", app.handler.AddReviewHandler).Methods("POST")
router.HandleFunc("/reviews/add", app.handler.CreateReviewHandler).Methods("POST")

// В файле app/router.go (или аналогичном)
adminRouter := router.PathPrefix("/admin").Subrouter()
adminRouter.HandleFunc("", app.handler.AdminDashboardHandler).Methods("GET")
adminRouter.Use(middlewares.AdminMiddleware) // проверка, что пользователь admin
// Дополнительные маршруты для админских операций, например, добавление/удаление книг и отзывов:
adminRouter.HandleFunc("/book/add", app.handler.AdminAddBookHandler).Methods("POST")
adminRouter.HandleFunc("/book/delete", app.handler.AdminDeleteBookHandler).Methods("POST")
adminRouter.HandleFunc("/review/delete", app.handler.AdminDeleteReviewHandler).Methods("POST")

log.Println("Сервер запущен на порту :8080")
if err := http.ListenAndServe(":8080", router); err != nil {
log.Fatal(err)
}
}
